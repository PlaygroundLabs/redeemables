// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import {IERC721} from "forge-std/interfaces/IERC721.sol";
import {DynamicTraits} from "./lib/DynamicTraits.sol";
import {SignedRedeem} from "./lib/SignedRedeem.sol";
import {RedeemableErrorsAndEvents} from "./lib/RedeemableErrorsAndEvents.sol";
import {RedeemableRegistryParams} from "./lib/RedeemableStructs.sol";

contract Redeemables is
    SignedRedeem,
    RedeemableErrorsAndEvents,
    DynamicTraits
{
    /// @dev The redeemable parameters stored by their hash.
    mapping(bytes32 redeemableParamsHash => RedeemableRegistryParams RedeemableParams)
        private _redeemableParams;

    /// @dev The redeemable URIs stored by params hash.
    mapping(bytes32 redeemableParamsHash => string redeemableURI)
        private _redeemableURIs;

    /// @dev The total redemptions by params hash.
    mapping(bytes32 redeemableParamsHash => uint256 count) _totalRedemptions;

    constructor() {}

    function updateRedeemableParams(
        RedeemableRegistryParams calldata params
    ) external {
        bytes32 paramsHash = _getRedeemableParamsHash(params);

        if (
            params.registeredBy != msg.sender
            // && !isApprovedForRedeemableParamsHash(msg.sender, redeemableParamsHash)
        ) revert NotOwnerOrApproved();

        RedeemableRegistryParams storage existingParams = _redeemableParams[
            paramsHash
        ];

        if (existingParams.redemptionSettingsAreImmutable)
            revert RedemptionSettingsAreImmutable();

        _redeemableParams[paramsHash] = params;

        emit RedeemableParamsUpdated(paramsHash, params);
    }

    function updateRedeemableURI(
        bytes32 redeemableParamsHash
    ) external view returns (string memory) {
        RedeemableRegistryParams storage params = _redeemableParams[
            redeemableParamsHash
        ];

        if (
            params.registeredBy != msg.sender
            // && !isApprovedForRedeemableParamsHash(msg.sender, redeemableParamsHash)
        ) revert NotOwnerOrApproved();

        return _redeemableURIs[redeemableParamsHash];
    }

    function ownerOverrideRedemptionCount(
        bytes32 redeemableParamsHash,
        uint256 tokenId,
        uint256 count
    ) external {
        RedeemableRegistryParams storage params = _redeemableParams[
            redeemableParamsHash
        ];

        if (
            params.registeredBy != msg.sender
            // && !isApprovedForRedeemableParamsHash(msg.sender, redeemableParamsHash)
        ) revert NotOwnerOrApproved();

        if (params.redemptionValuesAreImmutable)
            revert RedemptionValuesAreImmutable();

        _setTrait(tokenId, redeemableParamsHash, bytes32(count));
    }

    function redemptionStatsForToken(
        bytes32 redeemableParamsHash,
        uint256 tokenId
    ) public view returns (uint256 redeemedCount) {
        redeemedCount = uint256(getTrait(tokenId, redeemableParamsHash));
    }

    function redemptionStats(
        bytes32 redeemableParamsHash
    )
        public
        view
        returns (uint256 totalRedemptions, uint256 maxTotalRedemptions)
    {
        RedeemableRegistryParams storage params = _redeemableParams[
            redeemableParamsHash
        ];

        totalRedemptions = _totalRedemptions[redeemableParamsHash];
        maxTotalRedemptions = params.maxTotalRedemptions;
    }

    function getRedeemableParams(
        bytes32 redeemableParamsHash
    ) external view returns (RedeemableRegistryParams memory) {
        return _redeemableParams[redeemableParamsHash];
    }

    function redeemableURI(
        bytes32 redeemableParamsHash
    ) external view returns (string memory) {
        return _redeemableURIs[redeemableParamsHash];
    }

    function redeem(
        bytes32 redeemableParamsHash,
        uint256[] calldata tokenIds,
        uint256[] calldata amounts,
        bytes calldata signature,
        uint256 salt
    ) public {
        RedeemableRegistryParams storage params = _redeemableParams[
            redeemableParamsHash
        ];

        uint256 tokenIdsLength = tokenIds.length;

        if (tokenIdsLength != amounts.length) revert RedeemMismatchedLengths();

        uint256 totalAmount;
        for (uint256 i = 0; i < tokenIdsLength; i++) {
            totalAmount += amounts[i];
        }

        if (
            _totalRedemptions[redeemableParamsHash] + totalAmount >
            params.maxTotalRedemptions
        )
            revert MaxTotalRedemptionsReached(
                _totalRedemptions[redeemableParamsHash] + totalAmount,
                params.maxTotalRedemptions
            );

        if (_redeemSigner != address(0)) {
            _verifySignatureAndRecordDigest(
                msg.sender,
                tokenIds,
                salt,
                signature
            );
        }

        address tokenAddress = params.requiredToRedeem[0].token;

        for (uint256 i = 0; i < tokenIdsLength; i++) {
            _redeem(
                redeemableParamsHash,
                tokenAddress,
                tokenIds[i],
                amounts[i],
                params.maxRedemptions
            );
        }

        if (tokenIdsLength == 1) {
            emit Redeemed(tokenIds[0], msg.sender);
        } else {
            emit RedeemedBatch(tokenIds, msg.sender);
        }
    }

    function _redeem(
        bytes32 redeemableParamsHash,
        address tokenAddress,
        uint256 tokenId,
        uint256 amount,
        uint256 maxRedemptions
    ) internal {
        IERC721 token = IERC721(tokenAddress);
        address owner = token.ownerOf(tokenId);

        if (
            owner != msg.sender &&
            !token.isApprovedForAll(owner, msg.sender) &&
            token.getApproved(tokenId) != msg.sender
        ) revert NotOwnerOrApproved();

        uint256 count = redemptionStatsForToken(redeemableParamsHash, tokenId);

        if (count + amount > maxRedemptions)
            revert MaxRedemptionsReached(count + amount, maxRedemptions);

        _setTrait(tokenId, redeemableParamsHash, bytes32(count + amount));
        _totalRedemptions[redeemableParamsHash] += amount;

        for (uint256 i = 0; i < amount; i++) {
            // _burn(tokenId);
        }

        // params.receivedOnRedeem[0]._mint(owner, tokenId);
    }

    function _getRedeemableParamsHash(
        RedeemableRegistryParams calldata params
    ) internal pure returns (bytes32) {
        return keccak256(abi.encode(params));
    }

    function _checkActive(uint256 startTime, uint256 endTime) internal view {
  // Define a variable if the drop stage is inactive.
        bool inactive;

        // Using the same check for time boundary from Seaport.
        // startTime <= block.timestamp < endTime
        assembly {
            inactive := or(
                iszero(gt(endTime, timestamp())),
                gt(startTime, timestamp())
            )
        }

        // Revert if the drop stage is not active.
        if (inactive) revert NotActive(block.timestamp, startTime, endTime);
    }
}
